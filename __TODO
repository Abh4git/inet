 - hardware in the loop simulation using layered ethernet model and TSN
 - rename *Layered* modules to *Compound* or *Modular*? discuss!

 - PacketTransmitter without transmission channel should stop in initialize? otherwise duration parameters will not work

 - eliminate some typename != "" from NED files using default interface ommitted typenames if conditional connections are used
 - reduce redundancy among applications, e.g. add base application with parameterizable IO submodule, perhaps even create an IO base module which uses the ISocket interface

 - add examples/documentation for matching PCP value and destination MAC address for outgoing packets (identification)
 - example with Pcp and PriorityToTrafficClassClassifier classifier example
 - example with combined Ethernet virtual LANs and TSN features

 - duplicate animation from EthernetFcsChecker through NetworkInterface due to animate always going through the gate chain even though the packet stops at NetworkInterface to attach an InterfaceInd 
 - come up with realistic frame replication showcases such as multiple link breaks which still produce the traffic at the destination
 - replace GatingPriorityQueue with ShaperPriorityQueue/PriorityShaper?
 - add examples to flow measurements for store-and-forward, A-MPDU aggregation, preemption, cut-through and their effects on the bit and packet total times

 - naming things according to standards, have parameter names according to the standard
 - have modules named as TransmissionSelectionAlgorithm

 - implement multicast support in one gate scheduling configurator

 - compound figures should be updated to have a bounds property that contains all elements and they must not be over-determined (e.g. size vs plotSize) see topic/figures

 - refactor ICMP/ICMPv6 error message sending and error indication
   - separate sending an ICMP error message on the network from sending an ICMP error indication up to a transport protocol or an application
   - ICMP error indication must not contain an ICMP header but ICMP specific Ind tags instead
   - IPv4 can call both sendIcmpErrorMessage to send an ICMP error message on the network to a peer
     or it can call sendIcmpErrorIndication directly to send an ICMP Indication message (not a packet) to a transport protocol or an application
   - when ICMP is processing an incoming ICMP message (processIcmpMessage) it may be an error message (processsIcmpErrorMessage) which in turn
     should call the same sendIcmpErrorIndication that can also be called by Ipv4 or Udp, etc.
     the ICMP error indication should contain the quoted packet part in the form of a chunk or a packet for higher layer protocols to process
   - UDP must not understand ICMP headers, it should simply handle ICMP error indication messages (not packets) and the attached meta information
     when UDP sends up an error indication it should also attach all the received ICMP indication tags

 - ThruputMeteringChannel -> result filter + visualizer for measuring the channel throughput using channel signals and result for analysis
 - add Ethernet socket support to layered model.
 - implement fingerprints for figures and values for all example simulations.

 - code cleanup
   - update all EV statements to use EV_FIELD
   - replace cross module pointers with ModuleRef<T>
   - bitrate vs datarate
   - operator<<, printOn, str, etc. in all classes

 - handlePullPacketChanged can come from the queue when
   - a high priority frame is already being streamed and it gets interrupted
   - a low priority frame cannot be interrupted because it's already too close to its end (remaining minPacketLength)
   - in both cases a progress report is sent which is unnecessary and confusing

 - ethernet preemption example: 2nd out of 3 sends per packet must be avoided
   - add a check for whether the two packets are definitely equal or may be different?!
   - change the preamble insertion module to immediately start with a progress of 8 bytes and
   - change the transmitter to check if the at the progress update the expected progress position is at the end of the packet to skip the progress report

 - create release script (remove trailing spaces, replace leading tabs, fix header guards, format source code)

 - check Ethernet FCS progress report at the correct moment of time

 - add parameters to ScenarioManager disconnect operation to allow cutting connection at either end (source or destination)
   and also support disconnecting bidirectional connections in all four combinations.

 - generic TCP/UDP socket tagging, with automatic copying of tags to outgoing packets

 - temporal and spectral and spatial energy density
   - sampling
   - filling
   - integrating

 - similarly to timing API other meta-data could also be stored for the packet data per bit (e.g. hop count)
 - unify C++ namespaces, NED namespaces, folders and file names (e.g. ospfv vs. Ospf3*)
 - implement additional INET specific fingerprint ingredients: network interface configuration, routing table, mobility state, etc.
 - fix Ieee80211UnitDiskReceiver base class and initialize, solve diamond inheritance
 - extend timeGains/frequencyGains parsing with OMNeT++ 6.0 expression parser support (#ifdef)
 - extend PlotFigure with margin parameters
 - extend Units with double and simtime_t handling and use C++ units in division and multiplication functions
 - signal shared ptr cache
 - implement MemoizedFunction and multi dimensional domain subdivision tree
 - add parameter for orthogonal combinator function: multiplicative and minimum based
 - add parameter for bit error estimation: based on min(packet), mean(packet), min(mean(symbol))

 - chapter in developers guide about signals and statistics, naming convention, what constitutes a signal and what does not, etc.
 - existing protocols
   - 802.11 statistics, logging, display strings, code cleanup, memory management
   - complete IPv6
 - cross-cutting smaller changes
   - review end-to-end delay calculation
     - for applications it means the delay of complete application packets
     - for UDP it means the delay of datagrams
     - for TCP it means the delay of bytes
   - review NED documentation, update obsolete parts
   - add meaningful display strings to at least the top level submodules of network nodes (with optional formatting parameters)
   - finish renaming signals, labels, statistics to have a consistent naming scheme
   - review all examples to check if they still work as expected
 - new features
   - LTE PHY full support and porting to INET 4.0, source/sink separation, signal classes, etc. (e.g. probe/microwave oven)
 - port existing 3rd party models
   - help ANSA porting to INET 4.0

 - the packet dissector may need to do implicit chunk conversion because it has to choose a representation which may or may not be the same as the one in the packet (e.g. two interoperable frameworks)

 - change all protocols (where applicable) to accept any kind of cPacket (not only Packet) for interoperability with 3rd party projects 
 - remove obsolete HostAutoConfigurator, Ipv4FlatNetworkConfigurator modules?
 - 802.11 preamble, header, data separation in HT and VHT mode doesn't really make sense the way it's right now implemented
   there's no separate header in these modes, the preamble is much more complicated than in the other modes
   there's also a bug related to this in the Ieee80211ScalarTransmitter when it computes the data duration
 - add separate Ieee80211Socket
 - solve dynamic node creation and address resolution in applications
 - don't subclass APSK medium and such with other specific radios, think of APSK radio as yet another specific conceptual radio
 - move extra functions that doesn't really belong to L3AddressResolver (e.g. findInterfaceTableOf, findIPv4RoutingTableOf)
 - revise protocol base class hierarchy (e.g. LayeredProtocolBase vs IPv4 base class, etc.)
 - revise protocol header class hierarchy (e.g. avoid unnecessary interfaces)
 - revise NED network node module hierarchy (e.g. MPLS nodes)
 - use m instead of double in Coord?
 - replace functionality of GenericAppMsg with chunk tags, or better yet get rid of it altogether!
 - use shared pointers for transmissions/receptions, etc. because the gui copies packets in the packet log and inspects them later
 - factor out physical layer analog domain representation into a separate parameter of transmissions
 - review all examples and check if they still do what is intended
 - add separate reusable application packet generators
 - rewrite serializers that use structure bit fields, this is undefined C++ behavior
 - replace cCompoundModule class in hosts/nodes with a specific classes such as StandardHost
   providing getInterfaceTable, getMobility, getIPv4NetworkLayer, etc. to avoid random code fragments with getSubmodule(".ipv4.routingTable")???
   but we should avoid having these classes for a random collections of utility functions!
 - add separate classes/functions for iterating over the network nodes in a network or
   finding a network node based on its mac address/ip address or finding the position of a network node, etc.
 - add missing node NED files for existing protocols (e.g. sensor nodes, IoT devices) 
 - update all NED and C++ documentation, remove obsolete documentation
 - nicely position submodules in compound modules, prepare for 2 info lines
 - extend main protocol modules (and all submodules) with 2 info lines above the submodule icon
 - avoid specifying module icon sizes by default, override icon size in submodules

 - @descriptor(false) vs @descriptor(readonly); why do we have descriptor anything at all? why don't we have descriptors for all types all the time?
 - @editable(false) vs @descriptor(readonly)??? and in general editable is a GUI concept

 - DYMOSequenceNumber: class DYMOSequenceNumber??? why class? primitive class???
 - PacketDrop: packet_ -> packet
 - IntServ.msg: *_t is reserved for C++ standard
 - InterfaceEntry: eliminate @getter if possible
 - EtherType.msg: replace with Protocol.h?
 - IPProtocolId.msg: replace with Protocol.h?

 - review and refactor all applications which have lifecycle, startTime, endTime parameters, move code from initialize to separate reusable functions (e.g. for lifecycle restart)

 - DHCP Client should work multiple interfaces, but works with only one.

 - UDP: add a parameter: used protocol number, default value is UDP.
   It's useful for UDP-like protocols, e.g. MANET

 - revise ethernet/eth-index.ned! e.g it writes about autoconfiguration, and probably half of it is obsolete

 - examples/ospfv2/areas does not work: the UDP apps in H3 keep sending, but never receive answer; seems like
   sent packets cannot even leave H3 (they are queued up in ARP, due to "address resolution pending")

 - TCP,UDP,SCTP: Need revision for PORT_ANY usage:
   unspec port should be 0 not -1
   What will the PORT_ANY value: -1 or 0.
   Where do replace from PORT_ANY to a valid port: in TCPSocket or in
      TCPConnection::process_OPEN_ACTIVE/process_OPEN_PASSIVE
   Check it in other protocols.

 - TCPSegment, UDPPacket: use uint16_t for ports, uint32_t for sequence numbers, etc; also in the code!!!
   hint: first replace it somewhere with a type that CANNOT be cast to integer types, then let compile errors propagate the type change everywhere

 - implement missing models:
   Queueing (we have: FIFO, RED): CBQ, WFQ, RIO, Round Robin, Fair queueing Round Robin
   Suggested by VR:
     Wired: Circuit Switch, ATM(AAL2/AAL5,CBR/VBR/ABR), IP over ATM, PNNI, MPLS, DiffServ
     Wireless:  Adhoc routing:FSR/DSDV/ZRP/TORA/LENMMAR;Adhoc MAC:802.11, WTRP,
     TDMA; QoS supports for cross-layer design
     and also, Group Mobility,  etc.

 - provide default for RoutingTable.routingTableFile once xmlinline() is implemented in omnet.

 - PPP, Ethernet: should use signals (ModelChangeNotification) to detect if channel path breaks

 - implement node failure/recovery by using signals mechanism

 - VideoStrmReq problem on IPv6: 
   "Error in module (UDP) P62.server.udp (id=21): User error: (UDPPacket)VideoStrmReq arrived from lower layer without control info"

 - finish making gate names consistent in RTP modules

 - labelling:
   - add labels l2pkt/l3pkt/l4pkt to upper layer input/output of L1/L2/L3 protocols or modules? 
     i.e. NIC's upperLayerIn could be tagged as l3pkt, and IP's ifOut also as l3pkt
   - add @labels(node,configurator,!configurator) to FlatNetworkConfigurator and similar "singleton" modeules,
     to make them unique?
   - change the @labels(PPPFrame) label on pppg[] gates of hosts/routers to something slightly different
     (e.g. @labels(PPPFrame/pk)) so that PPPInterface does not appear in the palette on network level?

 - eliminate ARP overhead for PPP interfaces

 - examples\wireless\hosttohost: Readme mentions some "attached Excel sheet" which is missing!!!

 - failure/recovery (replacing with failed router is problematic!)
 - gate labelling for the NED editor

 - eliminate cast after dup(), like (AirFrame*)airframe->dup()

 - IRoutingTable6, ITED, etc!

 - routingTable optimizations from Gamer!

 - Document: decide interfaceId vs interfacePointer! issue: IPRoutingDecision contains interfaceID.
      if we change it to pointer, messages that are underway in the host during a deleteInterface()
      may crash!!! solution: use a vector inside InterfaceTable, and let each deleteInterface()
      leave a hole in it?

 - move "q=queue" too into the default display string
 - add gate @labels
 - rename TCPBasicClientApp to TCPRequestReplyClientApp ?
 - ethernet: ditch autoconfig and zero-datarate channels, use deliverOnReceptionStart and 10/100/1000Mbps channels!

 - rename the following TED.h methods to begin with a verb:
   unsigned int linkIndex(IPAddress advrouter, IPAddress linkid)
   unsigned int linkIndex(IPAddress localInf)
   IPAddress peerRemoteInterface(IPAddress peerIP)
   IPAddress primaryAddress(IPAddress localInf)

 - cache gate IDs to speed up sending

 - model link failures, via isDown() method of InterfaceEntry. L2 modules
   should understand isDown(), and FailureManager should be enhanced with
   linkdown/linkup commands. See email on list archive on 9/17/2006 10:34 AM

 - create NetworkInterfaces/Base subdirectory: AirFrame, WirelessMacBase, ChannelAccess, etc.

 - Ieee80211Mac to fire TxNotifDetails when Ack arrives for a frame. Mgmt layer
   to use this notification to learn when ProbeRequest or AssociationResponse
   has been transmitted.

 - ChannelControl: grid; instead of having pMax parameter, it should ask all
   radios and collect pMax from them! (or, directly the range!)

 - radio models: when calculating the probability of bit errors, snirMIN is
   assumed for the whole duration of the frame! This means that if snir
   changes along the packet duration, we overestimate the probability of
   bit error. (there should be proper integration there)

 - IReceptionModel:
   - improve it to be able to accomodate antenna gain: calculation function
     should take node positions, antenna directions (maybe this should be in
     some IDirectionalReceptionmodel, plugging into some AbstractDirectionalRadio?)
   - allow for implementing "good/bad channel"-type radio models (Gilbert-Elliot)
     e.g. containsBadChannelState(starttime, endtime)
   - allow the radio model to add extra noise over time, or modify received power
     over time, e.g. using functions like
       PowerList calculateReceivedPower(...)
       PowerList ambientNoise(...)
     (maybe this should be some IDetailedReceptionModel, plugging into
     a specialized version of AbstractRadio?)

 - implement ICMP rate limiting, see e.g bsd.mod/netinet/ip_icmp.c, badport_bandlim()
 - ICMP options: stopOnError (bool param), UDPBadPortSendICMP (bool param)

 - problem with NetworkConfigurator + RSVP's FailureManager: after deleting/recreating
   LSR, configured IP addresses and host routes to PPP peers get lost.
   Solution: implement failure/recovery with NF_FAILURE and NF_RECOVERY notifications!

 - "ack" in LinkStateMsg redundant? (never read)
   what is the TELinkInfo.state flag?
   what is UnResvBandwidth[8] indexed with? what is [4] and [7] that gets printed?

 - BUG: UDP ephemeral port setting: if chosen & stored in UDP, sending further dgrams need to look it up from the SockDesc...

 - reading routing files: it doesn't make sense to be able to manually set MULTICAST on an interface

 - implement IPv6 tunneling

 - added userId to TCPCommand -- rewrite TCPSocketMap to make use of userId
        - socket must be inserted into map before bind(), so that a userId can be assigned
        - what about incoming connections? how to assign userId to them?
           IF IT CANNOT BE DONE: remove userId from TCP!!!!

 - apps: add startTime param; IPAddressResolver should only be invoked at startTime not in initialize()!

 - Ethernet: restore original connection color when transmission ends

 - ICMP: shouldn't we unify ICMP and ICMPv6...? at least types and codes?
   ICMPv6 uses different type&code numeric values but this is only of interest
   if we want to do emulation

 - instead of sending up ICMP packet to UDP & TCP: create an ICMPErrorInfo, and
   IP (IPv6) would attach that to the bogus datagram, with message kind IP_I_ICMP_ERROR.
   (win: IP/ICMP dependencies can then be removed from TCP and UDP in makemakefiles!!!)

 - ErrorHandling is not used anymore! do we need to send a copy of ICMP errors to the
   ICMP module itself as well?

 - TCP: how to handle ICMP error reports?

 - MPLS/LDP/RSVP:
    - document! ScenarioManager commands, XML file formats, unimplemented features

Really old stuff
================
add support for integrating the TIREM module?
   http://www.alionscience.com/index.cfm?fuseaction=products.view&productid=19
   "TIREM predicts radio frequency propagation loss over irregular terrain and seawater for
   ground-based and air-borne transmitters and receivers. TIREM is commercially
   available as a DLL and as a module in leading commercial M&S tools."
-----------------------
mailing list post on 2008-11-17 "INET Framework accuracy":
A really interesting paper is the technical report "Towards Comparable
Network Simulators", from Pengfei Di, Yaser Houri, Kendy Kutzner and  Thomas
Fuhrmann [see url below]. They measure 802.11 throughput with ns2 and
OMNeT++ INET Fw, and come to the conclusion that they are hard to compare,
due to differences in the radio model and MAC parameterization. Then they go
on to wrap ns2's 802.11 model into an OMNeT++ simple module, and with that,
the OMNeT++ simulation (not too surprisingly) shows excellent correspondence
with the ns2 simulation :)

http://i30www.ira.uka.de/research/documents/p2p/2008/towards_comparable_netw
ork_simulations.pdf

The paper is excellent work, and literally cries for follow-ups:

1. INET's radio model is pluggable, and as the report authors describe it,
   the ns-2 radio model seems to be quite simple (i.e. propdelay is a constant
   and does not depend on distance). Thus, it should be possible to reimplement
   ns-2's radio model in OMNeT++ with not too much effort (and contribute it to
   INET) and re-run the experiments with it.

2. OTOH I'm wondering, why not test the radio model and the 802.11MAC
   operation *separately*? I.e. write an ideal radio (ber==0 always) and test
   different 802.11 MAC models over that in all scenarios; then have more
   realistic radio models and test them with simple (contention-free) 802.11
   setups

3. INET 802.11MAC model parameterization could be adjusted so that it's
   possible to set it up with *exactly* the same parameters as ns-2.

4. the authors ported ns-2's 802.11 model into OMNeT++; wonder if this code
   is publicly available, or is there any plan to release it? there certainly
   would be value in doing that.
-----------------------
into the ipv6 doc:
"
Currently, IPv6 support consists of several modules. The IPv6 module
implements IPv6 datagram handling (sending, forwarding etc). It relies on
RoutingTable6 to get access to the routes. RoutingTable6 also contains the
neighbour discovery data structures (dest cache, neighbour cache, prefix
list -- the latter effectively merged into the route table). Interface
configuration (address, state, timeouts etc) is held in the InterfaceTable,
in IPv6InterfaceData objects attached to InterfaceEntry as its ipv6()
member.

The module IPv6NeighbourDiscovery implements all tasks associated with
neighbour discovery and stateless address autoconfiguration. Its data
structures are in RoutingTable6 (dest cache, neighbour cache, prefix list).
Neighbour discovery packets are only sent and processed by this module --
when IPv6 receives one, it forwards the packet to IPv6NeighbourDiscovery.

The rest of ICMPv6 (ICMP errors, echo request/reply etc) is implemented in
the module ICMPv6, just like with IPv4. ICMP errors are sent into
IPv6ErrorHandling, which the user can extend or replace to get errors
handled in any way they like.
"

-----------------------
TCP:
Slow Start should be applied every time TCP starts to send "after a
sufficiently long idle period".

"Idle" could be interpreted as when the send queue is empty (there's nothing
to send), and there's no unacknowledged data (i.e. previously sent segments
have all been acknowledged). But what is "sufficiently long"? I guess that
should be measured in RTT rather than absolute time (secs). So maybe we
should say 5*RTT is "sufficiently long"?
-----------------------
FlatNetworkConfigurator: assigns the same address to all interfaces of a router.
This is not the usual way things are done on the internet. But if we assign
different addresses, which addr to use in the routing tables etc?
-----------------------
VOJTA:
 -make connect work without bind (autoassign local address based on
destination, currently unspecified address is sent and SYN+ACK will not
be sent back (at least for 127.0.0.1, I didn't check for others))
-----------------------
from http://www.freesoft.org/CIE/Course/Section3/10.htm:

# Per-interface assignment. IP addresses are assigned on a per-interface basis,
so a host might possess several IP addresses if it has several interfaces.
For example, a host with both Ethernet and serial interfaces would have an
IP address for each. This is an important consequence of prefix-based
addressing. An IP address doesn't really refer to a host, it refers to an
interface.

If a host is known by multiple addresses, then every service on this host
can be referred to by multiple names! Addressing this host requires picking
one of these. Since the packet is addressed to the interface and not the host,
path information is introduced into the address. The exact ramifications of
this effect depend heavily on the network design. In particular, careless
design can result in a host becoming reachable by one address but not by
another. The simplest solution to this problem is to select the host's most
reliable interface and advertise its IP address as the host's primary IP
address.

==> current FlatNetworkConfigurator is shit? how to do address assignment?

see also:
 "The Network Administrators' Guide" http://www.tldp.org/LDP/nag/node1.html
 "IP 101: All About IP Addresses" http://www.networkcomputing.com/netdesign/ip101c.html
  - according to this: network numbers and interface addresses don't necessarily
    have to do anything with each other! may look COMPLETELY different

from http://www.networkcomputing.com/netdesign/ip101.html:

The important thing to realize is that while a routing table keeps track of
network numbers, no one assigns a network number to any piece of equipment.
Every interface of a router or host connected on the network must have an IP
address and a subnet mask defined (many pieces of equipment will assign a
default subnet mask if none is applied). From this IP address and subnet mask,
the network number is derived by the IP stack and tracked in the routing table.

Q: if routing tables contain network numbers, are IP addresses of router
interfaces also addressable?
