[Config Simple]
network = MultidropNetwork
sim-time-limit = 1ms

# number of nodes can vary between 1 and 10
*.numNodes = ${numNodes=1..10}

# controller is an Ethernet PLCA network node
*.controller.typename = "EthernetPlcaNode"

# all nodes are Ethernet PLCA network nodes
*.node[*].typename = "EthernetPlcaNode"

# enable socket support in the Ethernet layer for the applications
*.*.ethernet.hasSocketSupport = true

# SPI configuration
*.*.spi.typename = "Spi2"
*.*.spi.speed = 10MHz
#*.*.spi.queue.typename = "DropHeadQueue"
#*.*.spi.queue.dataCapacity = 16kB

# encryption delay
*.*.encryption.delay = 10us

# PLCA max burst count
*.node[*].eth.plca.max_bc = 3

# 1 source and 1 sink application in each node
*.node[*].numApps = 2

# source application sends to controller
*.node[*].app[0].typename = "EthernetSourceApp"
*.node[*].app[0].io.interface = "eth0"
*.node[*].app[0].io.remoteAddress = "0A:AA:00:00:00:01" # controller MAC address
*.node[*].app[0].source.productionInterval = 2 * ${numNodes} * ${packetInterval=50,100,200,300,400,500,600,700,800,900,1000}us # the traffic fits into the channel capacity
*.node[*].app[0].source.packetLength = 46B # minimum Ethernet payload size

# sink application receives from controller
*.node[*].app[1].typename = "EthernetSinkApp"
*.node[*].app[1].io.interface = "eth0"
*.node[*].app[1].io.steal = true
*.node[0].app[1].io.localAddress = "0A:AA:00:00:00:02"
*.node[1].app[1].io.localAddress = "0A:AA:00:00:00:03"
*.node[2].app[1].io.localAddress = "0A:AA:00:00:00:04"
*.node[3].app[1].io.localAddress = "0A:AA:00:00:00:05"
*.node[4].app[1].io.localAddress = "0A:AA:00:00:00:06"
*.node[5].app[1].io.localAddress = "0A:AA:00:00:00:07"
*.node[6].app[1].io.localAddress = "0A:AA:00:00:00:08"
*.node[7].app[1].io.localAddress = "0A:AA:00:00:00:09"
*.node[8].app[1].io.localAddress = "0A:AA:00:00:00:0A"
*.node[9].app[1].io.localAddress = "0A:AA:00:00:00:0B"

# queue drops oldest packet first
*.node[*].eth[*].queue.typename = "DropHeadQueue"
*.node[*].eth[*].queue.dataCapacity = 16kB

# 1 sink application and 1 source application for each node
*.controller.numApps = 1 + ${numNodes}

# sink application receives packets from all nodes
*.controller.app[0].typename = "EthernetSinkApp"
*.controller.app[0].io.steal = true
*.controller.app[0].io.interface = "eth0"
*.controller.app[0].io.localAddress = "0A:AA:00:00:00:01"

# 1 source application for each node
*.controller.app[*].typename = "EthernetSourceApp"
*.controller.app[*].io.interface = "eth0"
*.controller.app[1].io.remoteAddress = "0A:AA:00:00:00:02"
*.controller.app[2].io.remoteAddress = "0A:AA:00:00:00:03"
*.controller.app[3].io.remoteAddress = "0A:AA:00:00:00:04"
*.controller.app[4].io.remoteAddress = "0A:AA:00:00:00:05"
*.controller.app[5].io.remoteAddress = "0A:AA:00:00:00:06"
*.controller.app[6].io.remoteAddress = "0A:AA:00:00:00:07"
*.controller.app[7].io.remoteAddress = "0A:AA:00:00:00:08"
*.controller.app[8].io.remoteAddress = "0A:AA:00:00:00:09"
*.controller.app[9].io.remoteAddress = "0A:AA:00:00:00:0A"
*.controller.app[10].io.remoteAddress = "0A:AA:00:00:00:0B"
*.controller.app[*].source.productionInterval = 2 * ${numNodes} * ${packetInterval}us # the traffic fits into the channel capacity
*.controller.app[*].source.packetLength = 46B # minimum Ethernet payload size
